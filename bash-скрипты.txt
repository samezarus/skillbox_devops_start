Заголовок:

    #!/bin/bash

DEBUG:

    bash -x ./script1.sh

    или в в теле прописать set -x

Внешние аргументы:

    $1, $2, $3 ...

        #!/bin/bash
        cp -r $1 $2
        rm -rf $1

Завершение скрипта:

    exit <код возврата>

        0   - успешное выполнение 
        1   - ошибка
        ...

Выставить права на исполнение:

    chmod +x ./<скрипт>.sh

Запуск скрипта в фоне:

    ./<скрипт>.sh &

Переменные окружения:

    $SHELL - оболочка
    $PWD - каталог тсполняемого скрипта
    $HOME - домашний каьалог текущего пользователя
    $USER - текущий пользователь
    $PATH - обсолютные пути для исполняемых файлов

    .bashrc - файл с подгружаемыми переменными окружения

    env - список всех переменных окружения текущего пользователя

    export <имя переменной>=<значение переменной> - создание (имя переменной без $)

Переменные shell-а:

    всегда в нижнем регистре

    <имя переменной>=<значение переменной> - создание

Переменные скрипта:

    Присвоение:

        <переменная> = <значение>

    Обращение:

        $<переменная>

    Переменная из результата команды: 
    
        Бэктики `` (на [Ё]):

            today=date +`%d-%m`

        Через $:

            today=$(date '+%d-%m')            

Запись в одну строку (;):

    echo "hellow" ; echo "world"

Специальные параметры:

    $? - код возврата последней выполненной команды

        0   - успешное выполнение 
        1   - ошибка (grep xxx 1.txt ; echo $?)
        2   - ошибка выполнения внутренних команд шела
        126 - команда не может быть выполнена
        127 - команда не найдена

    $* - все переданные позиционные параметры

    $# - кол-во переданных позиционных параметров

Команда test/[]:

    Псевдоним команды в скрипте "[<пробел><условие><пробел>]":

        "test -d /tmp" то же самое что и "[ -d /tmp ]"

    Строки:

        <строка1> = <строка2>  - равно (test a = b ; echo $? - ошибка 1) (test a = a ; echo $? - успех 0)
        <строка1> != <строка2> - не равно (test a != b ; echo $? - успех 0)
        -z <строка>            - проверка на равенство нулю (test -z a; echo $? - ошибка 1)
        -n <строка>            - проверка на неравенство нулю (test -n a; echo $? - успех 0)

    Числа:

        -eq - равно
        -ne - не равно
        -ge - больше либо равно
        -gt - строго больше
        -le - меньше либо равно
        -lt - строго меньше

    Файлы:

        -e <файл> - существует
        -f <файл> - существует и это файл
        -d <файл> - существует и каталог
        -g <файл> - существует и выставлен SGID (set-group-ID)
        -k <файл> - существует и выставлен липкий бит (sticky bit)
        -r <файл> - существует и выставлено право на чтение
        -s <файл> - существует и не пустой
        -u <файл> - существует и выставлен SUID (set-user-ID)
        -w <файл> - существует и выставлено право на запись
        -x <файл> - существует и выставлено право на выполнение

Операторы сравнения:

    -eq (equal)             равно
    -ne (not equal)         не равно
    -lt (less then)         меньше, чем
    -le (less oq equal)     меньше, или равно
    -gt (greater then)      больше, чем
    -ge (greater or equal)  больше или равно

Оператор if:

    if [ <условие1> ]; then
        <условие1 верно>
    elif [ <условие2> ]; then
        <условие2 верно>
    ...
    else
        <ни одно условие не верно>
    fi

    -a - and
    -o - or

    Если переменная строковая, то её лучше заключить в "" что бы ихбежать проблем с пробелами внутри строки

Арифметика:

    Операции:

        "+" - сложение
        "−" - вычитание
        "*" - умножение
        "/" - деление
        "**" - возведение в степень
        "%" - получение остатка от деления

    Выполнение:

        "*" нужно экранировать (\*)

        "let" - не имеет собственного вывода(принта)

            let x=5+3; echo $x
            let x=5+3 | echo $x

        "expr" - вывод результата сразу 
        (+ должен быть отделён пробелами) 
        (не может работать со скобками)

            expr 3 + 5
            echo $(expr 3 + 5)

            expr 3 \* 5


        "(( ))"

            echo $((5+3))
            ((x=5+3)) | echo $x

    bc (basic calculator):

        "+" - сложение
        "-" - вычитание
        "*" - умножение
        "/" - деление
        "%" - нахождение остатка от деления
        "^" - возведение в степень
        "=" - присваивание переменной значения

        "<"  - строго меньше
        "<=" - меньше либо равно
        ">"  - строго больше
        ">=" - больше либо равно
        "==" - равно 
        "!=" - не равно

        "sqrt(X)" - квадратный корень от X
        "s(X)"    - синус от X (X в радианах)
        "с(X)"    - косинус от X (X в радианах)
        "a(X)"    - арктангенс от X (X в радианах)
        "I(X)"    - натуральный логарифм от X
        "e(X)"    - экспонента от X

        Примеры:

            echo "2+2" | bc

            echo "var=10; var" | bc

            echo "10>5" | bc

            echo sqrt "(81)" | bc -l

Оператор case:

    case "$переменная" in
        "вариант1" ) команда ;;
        "вариант2" ) команда ;;
        *) команда
    esac

Оператор while:

    while [ <условие> ]
    do
        <Команда1>
        ...
    done

Оператор until:

Оператор for:

    for <аргумент> in <список/диапазон>
    do
        <Команда1>
        ...
    done

    Примеры:

        Список:

            for i in ya.ru vk.com google.com 
            do 
                ping -c1 -q $i
            done

            или

            for i in ya.ru vk.com google.com; do ping -c1 -q $i; done

        Диапазоны:

            for ((i=1;i<=10;i++)); do echo "Hello World!"; done

            for i in $(seq 1 10); do echo "Hello World!"; done

AWK - язык обработки текстовой информации:

    awk '<условие> { <действие> }'

        Примеры:

            awk 'BEGIN { print "Hellow world" }'

            ps auxf | awk '{ print $1 }'

                Вывод определённой колонки с разделителем пробел

            ps auxf | awk ' /'bash'/ { print $1 } '

                Вывод определённой колонки с её фильтрацией и разделителем пробел (фильтр в виде строки: /'<строка>'/)

            ps auxf | awk ' /'bash'/ { print $0 } '

                Вывод определённой строки с её фильтрацией (аналог grep) (фильтр в виде строки: /'<строка>'/)

            awk -F ":" '{ print $1 }' /etc/passwd

                Вывод определённой колонки текста с указанием разделителя

            awk '{ print }' /etc/passwd

                Вывод файла
        
    Предопределённые внутренние переменные:

        NR - номер текущей строки:

            awk 'NR==3 { print }' /etc/passwd

                Вывод третьей строки

            awk 'NR % 2 != 0 { print }' /etc/passwd

                Вывод всех нечётных строк

            awk '{ print NR, $0 }' /etc/passwd

                Нумерация строк в файле

        NF - размер текущей строки:

            awk 'NF > 0' <имя файла>

                Вывод не пустых строк файла

        FS - разделитель полей:

    Встроенные функции:

            int() - приводит число к целому

            rand() - возвращает случайное число:

                awk 'BEGIN {print rand()}'

            srand() - устанавливает исходное значение:

                awk ' BEGIN { srand(); print int( rand()*100 ) } '

            length() - возвращает длину строки:

                awk ' { print length } ' /etc/passwd

            tolower() - возвращает строку, с преобразованием символов в строчные:

                echo "SOME TEXT IN UPPER CASE" | awk ' { print tolower($0) } '

                    Превести строку в нижний регистр

            toupper() - возвращает строку, с преобразованием символов в заглавные:

                echo "some text in lowe case" | awk '{print toupper($0)}'

                    Перевести с троку в верхний регистр

                awk -F ":" ' { $1=toupper($1); print } ' /etc/passwd

                    Данные разделяются(сплитятся как в python) ":", каждый первый элемент,
                    в каждой строке перевести в верхний регистр

SED - Потоковый текстовый редактор:

    https://soft-setup.ru/shpargalka-po-sed-v-linux-s-primerami/

    sed <инструкция> <файл/текст>:

        sed <команда> [<индекс начала, индекс конца>]<действие>/<что заменить>/<на что заменить>/<флаг> <файл>:

    Команды:

        -n - отключает вывод обрабатываемых строк (файла или текста)

        -i - запись изменений в файл !!! БЕЗ НЕГО В ФАЙЛ ИЗМЕНЕНИЯ НЕ ЗАПИШУТСЯ !!!

            -i.<расширение> - перед сохранением сохранить оригинал файла

        -e - 

    Действия:

        p - печать:

            sed -n 'p' /etc/passwd

                вывод содержимого файла

            sed -n '1p' /etc/passwd

                вывод первой строки файла

            sed -n '1p; 2p' /etc/passwd

                вывод первую и вторую строку файла

            sed -n '1, 4p' /etc/passwd

                вывод строк файла c 1-й по 4-ю

            sed -n '1, +4p' /etc/passwd

                вывод первых 5-ти строк файла

            sed -n '$p' /etc/passwd

                вывод последней строки файла

        d - удаление:

            sed '/^#/ d' ~/temp/1.txt

                Удалить(но не записать! см. "-i") из файла строки начинающиеся на "#"
            
            sed '/^$/d' ~/temp/1.txt

                Удалить все пустые строки

        s - замена подстроки:

            sed -e 's/$/.example.com/' ~/temp/1.txt

                В конец каждой строки подставить подстроку ".example.com"

            sed -e 's/xxx/***/' ~/temp/1.txt

                Заменить все строки равные "xxx" на подстроку "***"

            sed -e 's/i/I/' ~/temp/1.txt

                Замена в любой строке файла первой "i" на "I" (i'm is increment -> I'm is increment)

            sed -e 's/i/I/g' ~/temp/1.txt

                Замена в любой строке файла всех "i" на "I" (i'm is increment -> I'm Is Increment)
            
        с - замена строки:

            sed '3c\This is a modified line.' ~/temp/1.txt

                Замена третьей строки файла на подстроку "This is a modified line."

    Флаги:

        g - Все совпадения



