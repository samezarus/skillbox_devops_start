#!/bin/bash

# Что нужно сделать
# Как мы уже отмечали, программа rm не даёт права на ошибку и не поддерживает 
# механизма на случай, если вы ошиблись или передумали удалять файл. Давайте 
# это исправим. Напишите скрипт под названием delete, который будет вместо 
# удаления файла сжимать его (можно выбрать алгоритм gzip или lzma) и 
# перемещать в папку /home/username/TRASH.

# Что оценивается
# Каждый раз при запуске скрипт должен просматривать папку TRASH и удалять 
# из неё файлы старше 48 часов.

# Дополнительное задание.
# Сделайте так, чтобы наш скрипт delete поддерживал не только удаление 
# файлов, но и удаление директорий.

# HW-11:
# Доработайте скрипт delete.sh c учётом того, что файл, 
# который пользователь пытается удалить, 
# может быть символической или жёсткой ссылкой.

# Если это символическая ссылка, необходимо удалять её без архивирования и возвращать пользователю:
#   Сообщение о том, что удалена только ссылка;
#   Имя оригинального файла, на который ссылается символическая ссылка.

# Добавьте проверку, чтобы определить, является ли файл жёсткой ссылкой. 
#   Если да — удаляйте файл обычным способом и выводите 
#   пользователю список ссылок на этот файл.

##############################################################################


clear


function is_symlink(){
    # Функция определяет, является ли переданный объект симлинком
    
    link=$1

    test $(readlink $link)
}


function get_symlink_parent(){
    # Фунция пытается найти источник/родителя симлинка
    
    link=$1

    if is_symlink "$link"; then
        echo $(readlink "$link" -ef "$target_path")
    fi
}


function hard_links_count(){
    # Функция определяет кол-во хардлинков у файла
    # По мотивам - https://linux.die.net/man/1/stat

    link=$1

    # Переданный объект не найден
    if [ ! -e "$link" ]; then
        echo 0
    else
        echo $(stat -c %h $link)
    fi
}


function list_hard_links(){
    # Фуекция выводи список "родственных" файлов по inode-номеру
    
    link=$1

    if [ $(hard_links_count "$link") -gt 0 ]; then
        # Получаем inode-номер
        inode_number=$(stat -c %i $link)

        # Ищем "родственников" по inode-номеру везде, начиная с корня.
        # Ошибки прав доступа шлём по известному адресу (2>/dev/null)
        find / -inum $inode_number 2>/dev/null
    fi
}


function arc(){
    # Функция архивирования файла/каталога

    # Целевой файл/каталог (абсолютный путь)
    source=$1

    # Имя архива (абсолютный путь)
    destination=$2

    # Если входные параметры не пусты
    if [ ! -z $source -a ! -z $destination ]; then
        # Имя файла/каталога (из абсолютного)
        title=${source##*/}

        # Если файл, отсекаем расширение
        if [ -f "$source" ]; then
            title=${title%%.*}
        fi

        # Задаём абсолютный путь будущего архива
        full_name=$destination/$title.tar.gz

        # Сжатие
        tar -zcf "$full_name" "$source"
        echo "Ваолнена архивация: '$source' -> '$full_name'"
    else
        echo "В функцию 'arc' не переданы входные параметры. Пример: arc <файл/каталог> <имя архива>"
    fi
}


function delete(){
    # Функция удаления файла/каталога

    # Целевой файл/каталог (абсолютный путь)
    source=$1

    # Если входной параметр не пуст
    if [ ! -z $source ]; then
        #   Если файл
        if [ -f "$source" ]; then
            rm -f "$source"
            echo "Удалён файл '$source'"
        #   Если каталог(удаляем рекурсивно)
        elif [ -d "$source" ]; then
            rm -r -f "$source"
            echo "Удалён каталог '$source'"
        fi
    # В функцию не передан входной параметр
    else
        echo "В функцию 'delete' не передан входной параметр. Пример: delete <файл/каталог>"
    fi
}


function chek_for_delete(){
    # Функция проверяет дату создания файла с датой нижнего предела, 
    # если предел привышен, то файл удаляется

    # Целевой файл (абсолютный путь)
    source=$1

    # Дата предела, после которого следует удалить файл
    limit=$2

    # Если входные параметры не пусты
    if [ ! -z $source -a ! -z $limit ]; then

        # Склейка из даты и времени создания файла (в unix-время)
        date_stamp=$(ls -l --time-style=long-iso $source | awk '{ print $6 }')
        time_stamp=$(ls -l --time-style=long-iso $source | awk '{ print $7 }')
        datetime_stamp=$(date --date="$date_stamp $time_stamp" +"%s")

        # Получение предела, перед которым файл должен быть удалён (в формате unix-времени)
        limit_date=$(date --date="$(date '+%Y-%m-%d %H:%M') $limit hour ago" +"%s")

        # Если дата создания файла меньше предел, то удаляем файл
        if [ $limit_date -gt $datetime_stamp ]; then
            delete $source
            echo "    Дата создания превысила $limit часов"
        fi

    # В функцию не переданы входные параметры
    else
        echo "В функцию 'chek_for_delete' не переданы входные параметры. Пример: chek_for_delete <файл> <дата предела>"
    fi
}



# Задаём имя каталога корзины
trash_dir=~/TRASH

# Создаём каталог корзину
mkdir -p "$trash_dir"

# Имя скрипта
script=$(basename "$0")

# Полный(абсолютный) путь к цели
target=$1

# Предел удаления файлов в часах
hour_limit=48


# Удаляем файлы, если дата создания превышает 'hour_limit'
for name in $(ls $trash_dir); do
    # Абсолютный путь к файду
    full_name="$trash_dir/$name"

    # Проверяем, стоит ли удалить файл
    chek_for_delete $full_name $hour_limit        
done


# Если в скрипт не передали параметр, он же полный путь к архиву
if [ -z "${target}" ]; then
    echo "Скрипт ожидает цель для архивирования в виде первого параметра (Пример: ./$script <каталог/файл>)"
# Если переданная цель(файл/каталог) не существует
elif [ ! -e "$target" ]; then
    echo "Файл/каталог '$target' не найден"
# Если прошли плановые проверки
else
    # Обработка симлинка
    if is_symlink "$target"; then
        echo "Имя оригинального файла: '$(get_symlink_parent "$target")'"
        delete $target
        echo "Удалена только ссылка !"

    # Обработка хардлинка
    elif [ $(hard_links_count "$target") -gt 0 ]; then
        echo "Список ссылок:"
        list_hard_links "$target"

        # Архивируем файл
        arc "$target" "$trash_dir"

        # Удаляем файл
        delete "$target"

    # Обработка просто файлов (из домашки № 9)
    else
        # Архивируем файл/каталог
        arc "$target" "$trash_dir"

        # Удаляем файл/каталог
        delete "$target"
    fi
fi